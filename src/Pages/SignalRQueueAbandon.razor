@page "/signalrabandon"
@using AsterNET.Manager.Event
@using Microsoft.AspNetCore.SignalR.Client
@using System.Reactive.Subjects
@using System.Collections.Concurrent
@using System.Threading
@using Sufficit.AsteriskManager.Events
@using System.Dynamic
@using Newtonsoft.Json
@using System.Text.Json
@using System.Diagnostics
@inject NavigationManager NavigationManager
@inject ISnackbar Snackbar
@implements IAsyncDisposable

<MudGrid Spacing="0">    

    <MudTable Items="@Buffer" Hover="true" SortLabel="Ordenar" FixedHeader="true" Height="100%" Style="width: 100%">
        <ToolBarContent>
            <MudText Align="Align.Left" Typo="Typo.h6">Estado de extensões 
                @if (IsConnected)
                {
                    <MudIconButton Size="Size.Small" Icon="@Icons.Material.Filled.DoNotDisturb" Color="Color.Error" OnClick="DisposeConnection"></MudIconButton>
                }
                <MudText Align="Align.Left" Typo="Typo.subtitle1">( @hubConnection?.State ) :: (@countEvents)</MudText>
            </MudText>            
            <MudSpacer />
            <MudTextField Disabled="!IsConnected" Value="filterInput" ValueChanged="@((string __e) => OnSetFilter(__e))"  Placeholder="Filtro (Extensão | Ip)" Adornment="Adornment.Start" AdornmentIcon="@Icons.Material.Filled.Search" IconSize="Size.Medium" Class="mt-0"></MudTextField>
        </ToolBarContent>
        <HeaderContent>
            <MudTh><MudTableSortLabel InitialDirection="SortDirection.Descending" SortBy="new Func<QueueCallerAbandonEventInterface, object>(x=>x.Queue)">Horário</MudTableSortLabel></MudTh>
            <MudTh>Canal</MudTh>
            <MudTh><MudTableSortLabel SortBy="new Func<QueueCallerAbandonEventInterface, object>(x=>x.CallerIdNum)">Extensão</MudTableSortLabel></MudTh>
            <MudTh><MudTableSortLabel SortBy="new Func<QueueCallerAbandonEventInterface, object>(x=>x.HoldTime)">Estado</MudTableSortLabel></MudTh>
            <MudTh><MudTableSortLabel SortBy="new Func<QueueCallerAbandonEventInterface, object>(x=>x.Position)">Endereço</MudTableSortLabel></MudTh>
        </HeaderContent>
        <RowTemplate>
            <MudTd DataLabel="Horário">@context.Queue</MudTd>
            <MudTd DataLabel="Canal">@context.Channel</MudTd>
            <MudTd DataLabel="Extensão">@context.CallerIdNum</MudTd>
            <MudTd DataLabel="Estado">@context.HoldTime</MudTd>
            <MudTd DataLabel="Endereço">@context.Position</MudTd>
        </RowTemplate>
        <PagerContent>
            <MudTablePager PageSizeOptions="new int[]{50, 100}" />
        </PagerContent>
    </MudTable>
   
</MudGrid>
@code {
    private MessagesBuffer<QueueCallerAbandonEventInterface> Buffer = new MessagesBuffer<QueueCallerAbandonEventInterface>(100);
    private HubConnection hubConnection;
    private int countEvents;
    private string userInput;
    private string filterInput;

    protected override async Task OnInitializedAsync()
    {
        //messages.Buffer(20);
        hubConnection = new HubConnectionBuilder()
            .WithUrl(new Uri("https://apps.sufficit.com.br:26507/amihub"))
            .Build();

        hubConnection.On<string>("System", SystemCommunication);
        hubConnection.On<string, AMIQueueCallerAbandonEvent>("Event:QueueCallerAbandon", ReceiveEventHandler);
        hubConnection.Reconnecting += OnHubReconnecting;
        hubConnection.Reconnected += OnHubReconnected;
        hubConnection.Closed += OnHubClosed;

        await hubConnection.StartAsync();
    }
    
    #region CONECTIONS EVENTS

    async Task DisposeConnection()
    {
        await hubConnection.DisposeAsync();
    }
    
    async Task OnHubReconnected(string s)
    {
        SystemCommunication($"reconected: {s}");
        await hubConnection.SendAsync("SetFilter", filterInput);
    }

    async Task OnHubClosed(Exception ex)
    {
        if(ex != null)
        {
            SystemCommunication($"error on closed: {ex.Message}");
            Stopwatch sw = new Stopwatch();
            sw.Start();
            while (hubConnection.State != HubConnectionState.Connected)
            {
                try{
                    await hubConnection.StartAsync();                      
                }catch(Exception exx)
                {                    
                    SystemCommunication($"error on retrying ({sw.ElapsedMilliseconds})ms: {exx.Message}");
                    await Task.Delay(2000);
                }
            }
            await hubConnection.SendAsync("SetFilter", filterInput);
        }
        await Task.CompletedTask;
    }
    
    async Task OnHubReconnecting(Exception ex)
    {
        if(ex != null)
        {
            SystemCommunication($"error on reconecting: {ex.Message}");
        }
        await Task.CompletedTask;
    }
    
    #endregion

    private async Task OnSetFilter(string e)
    {
        await hubConnection.SendAsync("SetFilter", e);
        filterInput = e;

        // Aguarda um pouco para o filtro ser aplicado corretamente
        await Task.Delay(200);
        Buffer.Clear();
        countEvents = 0;
    }

    void SystemCommunication(string message)
    {       
        AddSnackbar(message);
        StateHasChanged();
    }

    public void AddSnackbar(string message)
    {
        Snackbar.Add(message, Severity.Normal, (options) =>
        {
            options.CloseAfterNavigation = true;
        });
    }
    
    void ReceiveEventHandler(string sender, AMIQueueCallerAbandonEvent eventObj)
    {
        countEvents++;
        Buffer.Add(eventObj);
        StateHasChanged();   
    }    
    
    public bool IsConnected => hubConnection.State == HubConnectionState.Connected;

    public async ValueTask DisposeAsync()
    {
        await hubConnection.DisposeAsync();
    }
}